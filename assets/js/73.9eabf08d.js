(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{342:function(n,t,a){"use strict";a.r(t);var e=a(14),l=Object(e.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("h3",{attrs:{id:"let声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let声明"}},[this._v("#")]),this._v(" let声明")]),this._v(" "),t("p",[this._v("示例：")]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[this._v('// console.log(abc) //暂时性死区(TDC)\n// let abc = \'123\'; //let特点，如果使用let声明的,必须在声明之后再使用，不能在声明前使用。\nlet web = "这是一段测试文字";\nfunction fun() {\n    //如果函数体内没有声明这个变量，它会去外部找，可以访问外部变量。\n    console.log(web) //这是一段测试文字\n}\nfun()\n\n// function abc() {\n//     console.log(zxc) //会报错，会产生暂时性死区，但不影响上面函数正常打印,所以规范必须写在声明之后进行使用\n//     let zxc = "测试文字"\n// }\n// abc()\n\n//b会报错，会出现暂时性死区，等价于let b; a = b; b = 3; //变量提升，会出现暂时性死区，会警示报错\n// function aaa(a = b, b = 3) {\n//     console.log(a)\n//     console.log(b)\n// }\n// aaa()\n\n//正确写法\nfunction aaa(a = 2, b = 3) {\n    console.log(a)\n    console.log(b)\n}\naaa()')])])])])}),[],!1,null,null,null);t.default=l.exports}}]);